
WHAT IS A GRAPH?
================

- A graph is essentially a visual representation of our models and their relationships.

- TYPES
    - Types are your models/entities.
    - A type has fields that can be tracked.




SETTING UP BABEL
================

- Babel is a JS compiler which allows us to use the latest JS code from ES6.
- Remember when you create a react app? Babel is already installed, but because we're just making a simple node express app, we need to physically install
    babel ourselves so when we use ES6 syntax, babel will compile down to ES5 which is what internet browsers understand.




CREATING A GRAPHQL API
======================

- An important point to note is that graphql is only a specification, not an implementation.
- There the implementation is entirely up to the developer himself.
- Another example of the distinction between between specification and implementation is ECMASCRIPT.
    - ECMASCRIPT is the JS specification. Browser engines like V8 and SpiderMonkey in Chrome and Firefox are
        implementations of those specs.
- GRAPHQL-YOGA is one of these implementations. This implementation provides one of the most advanced feature sets.




GRAPHQL SCALAR TYPES
====================

- A scalar type is just a type that stores a SINGLE value.

- String
- Boolean
- Int
- Float
- Id




CUSTOM TYPES
============

- A custom type is essentially an object made up of a set of fields of scalar types.


NOTE: When querying data within graphql, you need to be specific down to the particular scalar values.




MUTUTATIONS
===========

- The graphql mutation is an operation allows us to create, update and delete data.




THE INPUT TYPE
==============

- Every variable declared in the input can ONLY be a scalar type, you cannot use a custom type.




PRISMA
======

- There are 3 ways to connect our DB to our database:
    - 1. NATIVE DRIVERS: This is a very bare bones implementations that does not include abilities to migrate, validate data or 
            map our models and their relationships and be able to reflect that in our data.
    - 2. OBJECT RELATION MAPPING: This implementation is a mix of native drivers along with the nice to have features explained above. Examples of ORM's
            are SQLize and MONGOOSE if you are using an SQL or MONGO database respectvely.

- PRISMA IS ALSO AN ORM THAT IS DATABASE AGNOSTIC. So you can use MySQL, POSTGRESQL and MONGO.

- PRISMA 'wraps up' our DB and exposes it as a GraphQL API.
- Therefore, our NODE.js backend can read and write from the DB with GraphQL.
    - If the server wants to read data, it sends out a GraphQL query, and if it wants to create update or delete data, it sends off a GraphQL mutation, and If
        it wants to watch for updates, it sends off a GraphQL subscription.

- So what does the server do?
    - The server handles small but very important tasks such as USER AUTHENTICATION and DATA AUTHORISATION.